// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// UpdateNetworkSsid updateNetworkSsid
//
// swagger:model updateNetworkSsid
type UpdateNetworkSsid struct {

	// The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
	ApTagsAndVlanIds []*ApTagsAndVlanID `json:"apTagsAndVlanIds"`

	// auth mode
	AuthMode AuthMode `json:"authMode,omitempty"`

	// The client-serving radio frequencies. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')
	BandSelection string `json:"bandSelection,omitempty"`

	// The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.
	ConcentratorNetworkID string `json:"concentratorNetworkId,omitempty"`

	// The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
	DefaultVlanID int32 `json:"defaultVlanId,omitempty"`

	// Whether or not the SSID is enabled
	Enabled bool `json:"enabled,omitempty"`

	// encryption mode
	EncryptionMode EncryptionMode `json:"encryptionMode,omitempty"`

	// enterprise admin access
	EnterpriseAdminAccess EnterpriseAdminAccess `json:"enterpriseAdminAccess,omitempty"`

	// The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Layer 3 roaming with a concentrator' or 'VPN')
	IPAssignmentMode string `json:"ipAssignmentMode,omitempty"`

	// Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.
	LanIsolationEnabled bool `json:"lanIsolationEnabled,omitempty"`

	// The minimum bitrate in Mbps. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')
	MinBitrate float64 `json:"minBitrate,omitempty"`

	// The name of the SSID
	Name string `json:"name,omitempty"`

	// The download bandwidth limit in Kbps. (0 represents no limit.)
	PerClientBandwidthLimitDown int32 `json:"perClientBandwidthLimitDown,omitempty"`

	// The upload bandwidth limit in Kbps. (0 represents no limit.)
	PerClientBandwidthLimitUp int32 `json:"perClientBandwidthLimitUp,omitempty"`

	// The passkey for the SSID. This param is only valid if the authMode is 'psk'
	Psk string `json:"psk,omitempty"`

	// Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius' or '8021x-radius'
	RadiusAccountingEnabled bool `json:"radiusAccountingEnabled,omitempty"`

	// The RADIUS accounting 802.1x servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius' or '8021x-radius' and radiusAccountingEnabled is 'true'
	RadiusAccountingServers []*RadiusAccountingServer `json:"radiusAccountingServers"`

	// Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
	RadiusAttributeForGroupPolicies string `json:"radiusAttributeForGroupPolicies,omitempty"`

	// If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
	RadiusCoaEnabled bool `json:"radiusCoaEnabled,omitempty"`

	// radius failover policy
	RadiusFailoverPolicy RadiusFailoverPolicy `json:"radiusFailoverPolicy,omitempty"`

	// radius load balancing policy
	RadiusLoadBalancingPolicy RadiusLoadBalancingPolicy `json:"radiusLoadBalancingPolicy,omitempty"`

	// If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.
	RadiusOverride bool `json:"radiusOverride,omitempty"`

	// The RADIUS 802.1x servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius' or '8021x-radius'
	RadiusServers []*RadiusServer `json:"radiusServers"`

	// splash page
	SplashPage SplashPage `json:"splashPage,omitempty"`

	// Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
	UseVlanTagging bool `json:"useVlanTagging,omitempty"`

	// The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'
	VlanID int32 `json:"vlanId,omitempty"`

	// Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
	WalledGardenEnabled bool `json:"walledGardenEnabled,omitempty"`

	// Specify your walled garden by entering space-separated addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. 192.168.1.1/24 192.168.37.10/32 www.yahoo.com *.google.com). Meraki's splash page is automatically included in your walled garden.
	WalledGardenRanges string `json:"walledGardenRanges,omitempty"`

	// wpa encryption mode
	WpaEncryptionMode WpaEncryptionMode `json:"wpaEncryptionMode,omitempty"`
}

// Validate validates this update network ssid
func (m *UpdateNetworkSsid) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApTagsAndVlanIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncryptionMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnterpriseAdminAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRadiusAccountingServers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRadiusFailoverPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRadiusLoadBalancingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRadiusServers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSplashPage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWpaEncryptionMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdateNetworkSsid) validateApTagsAndVlanIds(formats strfmt.Registry) error {

	if swag.IsZero(m.ApTagsAndVlanIds) { // not required
		return nil
	}

	for i := 0; i < len(m.ApTagsAndVlanIds); i++ {
		if swag.IsZero(m.ApTagsAndVlanIds[i]) { // not required
			continue
		}

		if m.ApTagsAndVlanIds[i] != nil {
			if err := m.ApTagsAndVlanIds[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("apTagsAndVlanIds" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UpdateNetworkSsid) validateAuthMode(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthMode) { // not required
		return nil
	}

	if err := m.AuthMode.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("authMode")
		}
		return err
	}

	return nil
}

func (m *UpdateNetworkSsid) validateEncryptionMode(formats strfmt.Registry) error {

	if swag.IsZero(m.EncryptionMode) { // not required
		return nil
	}

	if err := m.EncryptionMode.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("encryptionMode")
		}
		return err
	}

	return nil
}

func (m *UpdateNetworkSsid) validateEnterpriseAdminAccess(formats strfmt.Registry) error {

	if swag.IsZero(m.EnterpriseAdminAccess) { // not required
		return nil
	}

	if err := m.EnterpriseAdminAccess.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("enterpriseAdminAccess")
		}
		return err
	}

	return nil
}

func (m *UpdateNetworkSsid) validateRadiusAccountingServers(formats strfmt.Registry) error {

	if swag.IsZero(m.RadiusAccountingServers) { // not required
		return nil
	}

	for i := 0; i < len(m.RadiusAccountingServers); i++ {
		if swag.IsZero(m.RadiusAccountingServers[i]) { // not required
			continue
		}

		if m.RadiusAccountingServers[i] != nil {
			if err := m.RadiusAccountingServers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("radiusAccountingServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UpdateNetworkSsid) validateRadiusFailoverPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.RadiusFailoverPolicy) { // not required
		return nil
	}

	if err := m.RadiusFailoverPolicy.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("radiusFailoverPolicy")
		}
		return err
	}

	return nil
}

func (m *UpdateNetworkSsid) validateRadiusLoadBalancingPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.RadiusLoadBalancingPolicy) { // not required
		return nil
	}

	if err := m.RadiusLoadBalancingPolicy.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("radiusLoadBalancingPolicy")
		}
		return err
	}

	return nil
}

func (m *UpdateNetworkSsid) validateRadiusServers(formats strfmt.Registry) error {

	if swag.IsZero(m.RadiusServers) { // not required
		return nil
	}

	for i := 0; i < len(m.RadiusServers); i++ {
		if swag.IsZero(m.RadiusServers[i]) { // not required
			continue
		}

		if m.RadiusServers[i] != nil {
			if err := m.RadiusServers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("radiusServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UpdateNetworkSsid) validateSplashPage(formats strfmt.Registry) error {

	if swag.IsZero(m.SplashPage) { // not required
		return nil
	}

	if err := m.SplashPage.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("splashPage")
		}
		return err
	}

	return nil
}

func (m *UpdateNetworkSsid) validateWpaEncryptionMode(formats strfmt.Registry) error {

	if swag.IsZero(m.WpaEncryptionMode) { // not required
		return nil
	}

	if err := m.WpaEncryptionMode.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("wpaEncryptionMode")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UpdateNetworkSsid) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UpdateNetworkSsid) UnmarshalBinary(b []byte) error {
	var res UpdateNetworkSsid
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
